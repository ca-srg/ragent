# プロセス間 Vectorize ステータス共有の実装プラン

## 問題

`webui` コマンドを起動しても、別プロセスで動いている `vectorize` コマンドの状態を検知できない。
現在の実装では状態管理がすべてインメモリで行われており、プロセス間の共有機構がない。

## 解決策

Unix Socket ベースの IPC (Inter-Process Communication) を実装する。

## アーキテクチャ

```
┌─────────────────────┐         ┌─────────────────────┐
│   vectorize         │         │     webui           │
│   (IPC Server)      │◄────────│   (IPC Client)      │
│                     │  Unix   │                     │
│  - ソケットを管理    │  Socket │  - 接続してクエリ    │
│  - ステータスを公開  │         │  - 制御コマンド送信  │
└─────────────────────┘         └─────────────────────┘
```

## 実装ファイル構成

```
internal/
└── ipc/
    ├── socket.go       # ソケットパス解決
    ├── protocol.go     # JSON-RPC 2.0 プロトコル定義
    ├── messages.go     # アプリケーション固有メッセージ型
    ├── server.go       # サーバー実装
    ├── client.go       # クライアント実装
    └── ipc_test.go     # テスト
```

## 詳細設計

### 1. ソケットファイルの場所

**パス決定ロジック:**
1. `$XDG_RUNTIME_DIR/ragent/ragent.sock` (Linux標準、macOS一部)
2. フォールバック: `/tmp/ragent-{uid}/ragent.sock`

**理由:**
- `/tmp/ragent.sock` はセキュリティリスク（他ユーザーがアクセス可能）
- UID を含めることでユーザー間を分離

### 2. プロトコル: JSON-RPC 2.0

**選択理由:**
- 人間が読める形式でデバッグが容易
- 拡張性が高い
- Go の JSON サポートが優秀
- 改行区切りでフレーミングがシンプル

**メッセージ形式:**
```json
--> {"jsonrpc":"2.0","id":"1","method":"status.get"}
<-- {"jsonrpc":"2.0","id":"1","result":{"state":"running","progress":45}}
```

### 3. メソッド一覧

| Method | 説明 |
|--------|------|
| `status.get` | プロセス状態取得 (idle/running/stopping/error) |
| `progress.get` | 進捗詳細取得 (処理ファイル数、現在のファイル、パーセンテージ等) |
| `control.stop` | 停止リクエスト (将来用) |

### 4. 複数プロセスの排他制御

- PIDファイル + `flock()` で排他ロック
- 起動時に既存ソケットへ接続試行
  - 失敗 → stale ソケット、削除して起動
  - 成功 → 別プロセス稼働中、エラー終了

### 5. エラーハンドリング

| 状況 | 対応 |
|------|------|
| vectorize 未起動 | `ErrNotRunning` → webui は "idle" として表示 |
| ソケット残存・プロセス死亡 | stale 検知 → ソケット削除 |
| 接続タイムアウト | `ErrTimeout` (デフォルト 5秒) |

---

## 変更対象ファイル

### 新規作成

| ファイル | 内容 |
|----------|------|
| `internal/ipc/socket.go` | ソケットパス解決ユーティリティ |
| `internal/ipc/protocol.go` | JSON-RPC 2.0 型定義 |
| `internal/ipc/messages.go` | StatusResponse, ProgressResponse 等 |
| `internal/ipc/server.go` | Server 構造体、Start/Shutdown、ハンドラ登録 |
| `internal/ipc/client.go` | Client 構造体、Connect、Call メソッド |
| `internal/ipc/ipc_test.go` | 統合テスト |

### 変更

| ファイル | 変更内容 |
|----------|----------|
| `cmd/vectorize.go` | IPC サーバー起動、ステータス更新呼び出し |
| `internal/webui/server.go` | IPC クライアント接続、外部プロセスステータス取得 |
| `internal/webui/api_handlers.go` | `/api/status` で IPC 経由のステータスをマージ |

---

## 実装タスク

### Phase 1: IPC 基盤 (internal/ipc)

1. `socket.go` - ソケットパス解決
2. `protocol.go` - JSON-RPC 2.0 型定義
3. `messages.go` - ステータス/進捗メッセージ型
4. `server.go` - サーバー実装 (Listen, Accept, ハンドラ)
5. `client.go` - クライアント実装 (Connect, Call)
6. `ipc_test.go` - 基本統合テスト

### Phase 2: vectorize コマンド統合

7. `cmd/vectorize.go` に IPC サーバー起動を追加
8. 処理中のステータス/進捗更新を IPC サーバーに通知

### Phase 3: webui コマンド統合

9. `internal/webui/server.go` に IPC クライアント追加
10. `/api/status` で外部プロセスのステータスを取得・マージ
11. SSE イベントに外部プロセス情報を含める

### Phase 4: 検証

12. 統合テスト追加
13. 手動検証

---

## 検証方法

### 自動テスト

```bash
go test -v ./internal/ipc/...
```

### 手動検証

1. **ターミナル1:** vectorize を follow モードで起動
   ```bash
   go run main.go vectorize --follow --interval 5m
   ```

2. **ターミナル2:** webui を起動
   ```bash
   go run main.go webui
   ```

3. **ブラウザ:** http://localhost:8081 を開き、ステータスが "running" と表示されることを確認

4. **確認項目:**
   - vectorize 起動前の webui は "idle" を表示
   - vectorize 起動後の webui は "running" を表示
   - vectorize 停止後、webui が "idle" に戻る
   - 進捗情報（処理ファイル数等）がリアルタイムで反映される

---

## 将来の拡張 (スコープ外)

- webui からの vectorize 再実行トリガー
- ファイルアップロード機能との連携
- 複数 vectorize インスタンスの管理
