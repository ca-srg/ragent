# MCP invocation_counts バグ修正計画

## 問題の概要

SQLite の `invocation_counts` テーブルで `mode="mcp"` のカウントが増加しない。
現状: MCPツールを何度呼び出しても `count=1` のまま。

## 根本原因

`metrics.RecordInvocation(metrics.ModeMCP)` が **MCPサーバー起動時に1回だけ** 呼ばれており、**個々のツール呼び出し時には呼ばれていない**。

### 現在の実装

| 場所 | コード | 問題点 |
|------|--------|--------|
| `cmd/mcp-server.go:120` | `metrics.RecordInvocation(metrics.ModeMCP)` | サーバー起動時のみ実行 |
| `hybrid_search_handler.go:64` | `recordMCPMetrics(...)` | OTel メトリクスのみ、SQLite未記録 |

### 比較: 他モードの実装

- **Query** (`cmd/query.go:109`): クエリ実行時に毎回 `RecordInvocation` を呼出
- **Chat** (`cmd/chat.go:77`): チャット開始時に毎回呼出
- **Slack** (`cmd/slack.go:34`): Bot起動時に呼出

## 修正方針

**`hybrid_search_handler.go`** の `HandleSDKToolCall()` 内でツール呼び出しごとに `RecordInvocation` を呼び出す。

### 理由

1. SDK ベースの現アーキテクチャでツール呼び出しごとに必ず実行される
2. OTel メトリクス記録と同じ場所で SQLite も記録することで一貫性を保つ
3. 最小限の変更で修正可能

## 修正対象ファイル

### 1. `internal/mcpserver/hybrid_search_handler.go`

**変更内容**: `HandleSDKToolCall()` の冒頭で `metrics.RecordInvocation` を呼出

```go
import (
    // 追加
    "github.com/ca-srg/ragent/internal/metrics"
)

func (hsh *HybridSearchHandler) HandleSDKToolCall(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // 追加: ツール呼び出しごとに MCP invocation をカウント
    metrics.RecordInvocation(metrics.ModeMCP)
    
    // ... 既存コード ...
}
```

**行番号**: 
- import追加: 11-20行目付近
- 関数内追加: 47行目付近 (関数の冒頭)

### 2. `internal/mcpserver/slack_search_handler.go`

**変更内容**: 同様に `HandleSDKToolCall()` で `RecordInvocation` を呼出

```go
import (
    // 追加
    "github.com/ca-srg/ragent/internal/metrics"
)

func (ssh *SlackSearchHandler) HandleSDKToolCall(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // 追加: ツール呼び出しごとに MCP invocation をカウント
    metrics.RecordInvocation(metrics.ModeMCP)
    
    // ... 既存コード ...
}
```

**行番号**:
- import追加: 6-15行目付近
- 関数内追加: 40行目付近 (関数の冒頭)

### 3. `cmd/mcp-server.go` (オプション)

**変更内容**: 起動時の `RecordInvocation` 呼出を削除またはコメントアウト

```go
func runMCPServer(cmd *cobra.Command, args []string) error {
    // 削除: metrics.RecordInvocation(metrics.ModeMCP)
    // サーバー起動ではなくツール呼び出しでカウントするため
```

**行番号**: 120行目

**注意**: この変更は任意。サーバー起動回数もカウントしたい場合は残す選択肢もある。

## 検証方法

1. **単体テスト**: `internal/metrics/store_test.go` で既存テストがパスすることを確認
2. **統合テスト**:
   ```bash
   # MCP サーバー起動
   ./RAGent mcp-server &
   
   # ツール呼び出し (複数回)
   curl -X POST http://localhost:8080/ \
     -H "Content-Type: application/json" \
     -d '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"hybrid_search","arguments":{"query":"test"}},"id":1}'
   
   curl -X POST http://localhost:8080/ \
     -H "Content-Type: application/json" \
     -d '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"hybrid_search","arguments":{"query":"test2"}},"id":2}'
   
   # SQLite確認
   sqlite3 ~/.ragent/stats.db "SELECT * FROM invocation_counts WHERE mode='mcp';"
   # 期待結果: count が呼び出し回数と一致
   ```

3. **既存テスト実行**:
   ```bash
   go test -v ./internal/metrics/...
   go test -v ./internal/mcpserver/...
   ```

## 影響範囲

- `invocation_counts` テーブルの `mode="mcp"` のカウントが正確になる
- 既存の OTel メトリクス (`ragent.mcp.requests.total`) には影響なし
- レガシーサーバー (`server.go`) は現在使用されていないため修正不要

## リスク

- 低リスク: 追加のログ/カウント呼出のみで、既存ロジックに影響なし
- `metrics.Init()` が呼ばれていない場合の遅延初期化は既に `RecordInvocation` 内で対応済み

---

## 追加: 自動テスト計画

### 目的

MCP ツール呼び出し時に SQLite の `invocation_counts` テーブルの count が正しく増加することを検証するテストを追加する。

### テストファイル

`internal/mcpserver/hybrid_search_handler_test.go` (新規作成)

### テスト設計

```go
package mcpserver

import (
    "context"
    "path/filepath"
    "testing"
    "time"

    "github.com/ca-srg/ragent/internal/metrics"
    "github.com/modelcontextprotocol/go-sdk/mcp"
)

func TestHandleSDKToolCall_RecordsInvocationCount(t *testing.T) {
    // 1. テスト用の一時DBをセットアップ
    metrics.ResetForTesting()
    defer metrics.ResetForTesting()

    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, "test_stats.db")
    store, err := metrics.NewStoreWithPath(dbPath)
    if err != nil {
        t.Fatalf("Failed to create store: %v", err)
    }
    defer store.Close()
    
    // 2. グローバルストアをテスト用に差し替え
    metrics.SetStoreForTesting(store)

    // 3. 初期カウント確認 (0であるべき)
    today := time.Now().Format("2006-01-02")
    initialCount, _ := store.GetCountByDate(metrics.ModeMCP, today)
    if initialCount != 0 {
        t.Errorf("Expected initial count 0, got %d", initialCount)
    }

    // 4. HybridSearchHandler を作成（依存性は nil でOK - RecordInvocation のみテスト）
    handler := &HybridSearchHandler{adapter: nil}

    // 5. HandleSDKToolCall を呼び出し（エラーは想定内）
    // adapter が nil なので panic/error するが、RecordInvocation は先に呼ばれる
    func() {
        defer func() { recover() }()  // panic をキャッチ
        ctx := context.Background()
        req := &mcp.CallToolRequest{
            Params: &mcp.CallToolParams{Name: "hybrid_search"},
        }
        _, _ = handler.HandleSDKToolCall(ctx, req)
    }()

    // 6. カウントが1に増加していることを確認
    count, err := store.GetCountByDate(metrics.ModeMCP, today)
    if err != nil {
        t.Fatalf("GetCountByDate failed: %v", err)
    }
    if count != 1 {
        t.Errorf("Expected count 1 after tool call, got %d", count)
    }

    // 7. 2回目の呼び出し
    func() {
        defer func() { recover() }()
        ctx := context.Background()
        req := &mcp.CallToolRequest{
            Params: &mcp.CallToolParams{Name: "hybrid_search"},
        }
        _, _ = handler.HandleSDKToolCall(ctx, req)
    }()

    // 8. カウントが2に増加していることを確認
    count, err = store.GetCountByDate(metrics.ModeMCP, today)
    if err != nil {
        t.Fatalf("GetCountByDate failed: %v", err)
    }
    if count != 2 {
        t.Errorf("Expected count 2 after second tool call, got %d", count)
    }
}
```

### テストのポイント

1. **`metrics.ResetForTesting()`**: グローバル状態をクリーンアップ
2. **`metrics.SetStoreForTesting(store)`**: テスト用SQLiteを注入
3. **`t.TempDir()`**: Go標準の一時ディレクトリ（テスト後自動削除）
4. **`recover()`**: adapter が nil のため発生するpanic をキャッチしてテスト継続
5. **カウント検証**: `store.GetCountByDate()` で直接SQLiteを確認

### 実行コマンド

```bash
go test -v -run TestHandleSDKToolCall_RecordsInvocationCount ./internal/mcpserver/...
```
