# Plan: vectorize --follow 実行中に webui で Status: idle と表示される問題の修正

## 問題の概要

`vectorize --follow` コマンドを実行した後に `webui` サーバーを起動すると、`Status: idle` と表示されてしまう。外部プロセスの状態が正しく反映されていない。

## 原因分析

### 根本原因
`vectorize --follow` は interval 間で **待機中** のときに `StateIdle` を設定している。

`cmd/vectorize.go:486-488`:
```go
// Update IPC status to idle with final results
if ipcServer != nil {
    ipcServer.SetState(ipc.StateIdle)
```

しかし、`webui` の `api_handlers.go:41-44` では:
```go
// If external process is running and webui is idle, show as "running"
if response.ExternalProcess.Running && response.Status == StatusIdle {
    response.Status = StatusRunning
}
```

ここで `extStatus.Status.State == "running"` のチェックをしているが、follow mode が interval 待機中は `idle` 状態なので、`Running: false` になってしまう。

### 問題点
- **follow mode の "待機中" と "完全に停止" を区別できない**
- `idle` 状態は「次の実行を待機中」と「プロセスが終了」の両方を意味してしまっている
- webui は外部プロセスが存在するか（IPC 接続可能か）のみで判断すべき

## 解決策

### 選択肢 A: 新しい状態 `StateWaiting` を追加（推奨）

follow mode の待機中を表す新しい状態を追加する。

**変更ファイル:**
1. `internal/ipc/messages.go` - `StateWaiting ProcessState = "waiting"` を追加
2. `cmd/vectorize.go:486-488` - `SetState(ipc.StateIdle)` → `SetState(ipc.StateWaiting)`
3. `internal/webui/api_handlers.go:31,42` - `waiting` 状態も「実行中」として表示

**メリット:**
- 状態が明確に区別される
- UIで「次の実行まで待機中」と表示可能
- 既存のロジックへの影響が少ない

### 選択肢 B: IPC 接続可能 = 外部プロセス存在として扱う

`webui` で IPC に接続できれば、状態に関係なく外部プロセスが存在すると判断する。

**変更ファイル:**
1. `internal/webui/api_handlers.go:29-44` - `Running` の判定ロジックを変更

**メリット:**
- 変更箇所が少ない
- 新しい状態を追加しない

**デメリット:**
- 「実行中」と「待機中」の区別がUIでできない

## 確定: 選択肢 A を実装

### 実装計画

#### 1. `internal/ipc/messages.go` に `StateWaiting` を追加

L8-13 を変更:
```go
const (
    StateIdle     ProcessState = "idle"
    StateRunning  ProcessState = "running"
    StateWaiting  ProcessState = "waiting"  // 追加: follow mode で次の実行を待機中
    StateStopping ProcessState = "stopping"
    StateError    ProcessState = "error"
)
```

#### 2. `cmd/vectorize.go` の follow mode 完了時の状態を変更

L488:
```go
// 変更前
ipcServer.SetState(ipc.StateIdle)

// 変更後
ipcServer.SetState(ipc.StateWaiting)
```

#### 3. `internal/webui/api_handlers.go` で waiting 状態も検知

L30-31 を変更:
```go
// 変更前
response.ExternalProcess = &ExternalProcessStatus{
    Running: extStatus.Status.State == "running",

// 変更後
response.ExternalProcess = &ExternalProcessStatus{
    Running: extStatus.Status.State == "running" || extStatus.Status.State == "waiting",
```

これにより、`waiting` 状態も `Running: true` として扱われ、L42-44 のロジックで webui の Status が `running` に更新される。

### 変更対象ファイル一覧

| ファイル | 行番号 | 変更内容 |
|---------|--------|---------|
| `internal/ipc/messages.go` | L10-11 | `StateWaiting` 定数を追加 |
| `cmd/vectorize.go` | L488 | `StateIdle` → `StateWaiting` に変更 |
| `internal/webui/api_handlers.go` | L31 | `waiting` 状態も `Running: true` として扱う |

## 検証方法

1. `go build -o RAGent` でビルド
2. ターミナル1: `./RAGent vectorize --follow --interval 1m` を実行
3. ターミナル2: `./RAGent webui` を実行
4. ブラウザで `http://localhost:8081` にアクセス
5. ステータスが `idle` ではなく、`waiting` または外部プロセスの存在が表示されることを確認
6. `go test ./internal/ipc/... ./internal/webui/...` でテストを実行
